---
title: 反转链表
layout: post
tags:
  - leetcode
  - linked list
categories:
  - 数据结构
  - linked list
---

### 反转链表(Reverse a Singly Linked List)

要求：Given the pointer/reference to the head of a singly linked list, reverse it and return the pointer/reference to the head of reversed linked list.

<!-- more -->

![](/uploads/1.jpg)
#### solution1 iterative:

> runtime complexity: O(n)
>
> memory complexity: O(1)

如果单链表只有1个或者0个节点，直接返回。

如果有两个以上节点，则需要两个指针(引用)去迭代这个单链表

- **reversed**指针：指向已经反转的头节点(始于head指针)
- **list_to_do**指针：指向还没操作节点(始于head->next指针)

当reversed->next等于NULL时候，reversed指针就指向最后一个节点了，而且这个节点就是已经反转完成单链表的头节点

每一次迭代，list_to_do指针向前移动一个，直到它指NULL。这时候返回reversed指针即可

```python

def reverse_iterative(head):
    if head == None or head.next == None:
      	return head
    list_to_do = head.next
    reversed_list = head
    reversed_list.next = None
    
    while (list_to_do != None):
      	temp = list_to_do
        list_to_do = list_to_do.next
        
        temp.next = reversed_list
        reversed_list = temp
    return reversed_list
```

#### solution2 recursive

> runtime complexity: O(n)
>
> memory complexity: O(n)

需要注意的是递归需要用到stack，如果链表很大会导致run out of memory

需要两个指针来完成这个递归

- **reversed_list**: 指向已经反转的头节点
- **head**: 指向当前的节点

![head指向最后一个节点](https://ws2.sinaimg.cn/large/006tNc79gy1g2fbrn868oj31900ry76l.jpg)

当head指向原链表的最后一个节点时候，则直接返回其节点并赋值给reversed_list指针。接着依次把栈顶的节点拿出来并且head指向其节点，让其节点原来的后节点->next指向自己，并且自己->next指向None。

![image-20190426075048138](https://ws1.sinaimg.cn/large/006tNc79gy1g2fp9gqkjyj31280sutat.jpg)

```python
def reverse_recursive(head):
  	if head == None or head.next == None:
    		return head
    reversed_list = reverse_recursive(head.next)
    head.next.next = head
    head.next = None
    return reversed_list
```

